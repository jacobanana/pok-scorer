<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pok Detector Calibrator</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        /* Calibrator-specific styles */

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .panel h2 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }


        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-group label {
            font-size: 12px;
            color: #aaa;
        }


        .progress-section {
            margin-top: 15px;
        }

        .progress-bar-container {
            background: #333;
            border-radius: 4px;
            height: 24px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a90d9, #2ecc71);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #888;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .result-card {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .result-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90d9;
        }

        .result-card .label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .result-card.highlight .value {
            color: #2ecc71;
        }

        .params-output {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .per-image-results {
            margin-top: 15px;
        }

        .per-image-results h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .image-result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #333;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .image-result-row .filename {
            font-weight: 500;
        }

        .image-result-row .metrics {
            display: flex;
            gap: 15px;
            color: #888;
        }

        .image-result-row .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .image-result-row .metric-value {
            color: #4a90d9;
            font-weight: 500;
        }

        .buttons-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }


        .log-output {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid #333;
        }

        .log-entry.best {
            color: #2ecc71;
            font-weight: bold;
        }

        .validation-image-card {
            background: #333;
            border-radius: 6px;
            padding: 15px;
        }

        .validation-image-card h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #fff;
        }

        .validation-canvas-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .validation-canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .validation-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 12px;
        }

        .validation-metric {
            background: #2a2a4a;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .validation-metric-label {
            color: #888;
            font-size: 10px;
            margin-bottom: 3px;
        }

        .validation-metric-value {
            color: #4a90d9;
            font-weight: bold;
            font-size: 14px;
        }

        .validation-metric-value.good {
            color: #2ecc71;
        }

        .validation-metric-value.bad {
            color: #e74c3c;
        }

        .dataset-status-table {
            font-size: 12px;
        }

        .dataset-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #444;
            gap: 10px;
        }

        .dataset-status-row:last-child {
            border-bottom: none;
        }

        .dataset-status-filename {
            flex: 1;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .dataset-status-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .dataset-status-icon.loaded {
            background: #2ecc71;
            color: white;
        }

        .dataset-status-icon.missing {
            background: #e74c3c;
            color: white;
        }

        .dataset-status-summary {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
            text-align: center;
        }

        .dataset-status-summary-value {
            font-size: 18px;
            font-weight: bold;
            color: #4a90d9;
            margin-bottom: 3px;
        }

        .dataset-status-summary-value.complete {
            color: #2ecc71;
        }

        .dataset-status-summary-label {
            color: #888;
            font-size: 11px;
        }

        #iterationResultsTable th {
            color: #aaa;
            font-weight: 600;
            font-size: 10px;
            text-transform: uppercase;
        }

        #iterationResultsTable tbody tr {
            border-bottom: 1px solid #333;
        }

        #iterationResultsTable tbody tr:hover {
            background: #2a2a3a;
        }

        #iterationResultsTable tbody td {
            padding: 6px 4px;
            text-align: center;
            color: #ccc;
        }

        .iteration-row-best-combined {
            background: rgba(46, 204, 113, 0.15) !important;
        }

        .iteration-row-best-combined td:nth-child(2) {
            font-weight: bold;
            color: #2ecc71;
        }

        .iteration-cell-best {
            font-weight: bold;
            color: #4a90d9;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="main-nav">
        <a href="annotation-editor.html" class="nav-link">
            <span class="nav-step">1</span>
            <span class="nav-label">Dataset Editor</span>
        </a>
        <span class="nav-arrow">→</span>
        <a href="calibrator.html" class="nav-link active">
            <span class="nav-step">2</span>
            <span class="nav-label">Calibrate</span>
        </a>
        <span class="nav-arrow">→</span>
        <a href="index.html" class="nav-link">
            <span class="nav-step">3</span>
            <span class="nav-label">Detect</span>
        </a>
    </nav>

    <div class="page-content">
        <h1>Pok Detector Calibrator</h1>
        <p class="subtitle">Auto-tune detection parameters using annotated images</p>

        <div class="container" style="display: grid; grid-template-columns: 1fr 320px; gap: 20px; align-items: start;">
        <div>
        <!-- Step 1: Load Dataset -->
        <div class="panel">
            <h2><span class="step-number" id="step1">1</span> Load Dataset</h2>

            <div class="info-box" style="margin-bottom: 15px;">
                Create a JSON file with annotated pok positions using the <a href="annotation-editor.html">Dataset Editor</a>,
                or load a saved dataset from localStorage.
            </div>

            <div class="file-input-group">
                <input type="file" id="datasetInput" accept=".json">
                <button class="btn-primary" onclick="document.getElementById('datasetInput').click()">
                    Load JSON File
                </button>
                <button class="btn-secondary" onclick="loadDatasetFromStorage()">
                    Load from Storage
                </button>
                <span class="file-status" id="datasetStatus"></span>
            </div>
        </div>

        <!-- Step 2: Load Images -->
        <div class="panel">
            <h2><span class="step-number" id="step2">2</span> Load Images</h2>

            <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
                Select the image files referenced in your dataset.
                Filenames must match exactly.
            </p>

            <div class="file-input-group">
                <input type="file" id="imagesInput" accept="image/*" multiple>
                <button class="btn-primary" id="loadImagesBtn" onclick="document.getElementById('imagesInput').click()" disabled>
                    Load Images
                </button>
                <span class="file-status" id="imagesStatus"></span>
            </div>

            <!-- Dataset Split Summary -->
            <div id="datasetSplitSummary" class="hidden" style="margin-top: 15px;">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #aaa;">Dataset Split Preview</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: #333; padding: 12px; border-radius: 6px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 5px;">Training Set</div>
                        <div id="trainingSummary" style="font-size: 11px; color: #aaa;"></div>
                    </div>
                    <div style="background: #333; padding: 12px; border-radius: 6px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 5px;">Validation Set</div>
                        <div id="validationSummary" style="font-size: 11px; color: #aaa;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Configure & Run -->
        <div class="panel">
            <h2><span class="step-number" id="step3">3</span> Configure & Run Optimization</h2>

            <div class="settings-grid" style="margin-bottom: 20px;">
                <div class="setting-group">
                    <label>Random Search Iterations</label>
                    <input type="number" id="randomIterations" value="50" min="10" max="500">
                </div>
                <div class="setting-group">
                    <label>Local Search Iterations</label>
                    <input type="number" id="localIterations" value="100" min="20" max="500">
                </div>
                <div class="setting-group">
                    <label>Match Distance Threshold (px)</label>
                    <input type="number" id="matchThreshold" value="50" min="10" max="200">
                </div>
                <div class="setting-group">
                    <label>Training Set Ratio (%)</label>
                    <input type="number" id="trainRatio" value="70" min="50" max="90" step="5">
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 15px;">
                <strong>Optional:</strong> Load existing parameters to use as starting point for optimization
                <div class="file-input-group" style="margin-top: 10px;">
                    <input type="file" id="startingParamsInput" accept=".json" style="display: none;">
                    <button class="btn-secondary" onclick="document.getElementById('startingParamsInput').click()">
                        Load Starting Parameters
                    </button>
                    <span class="file-status" id="startingParamsStatus"></span>
                </div>
            </div>

            <div class="buttons-row">
                <button class="btn-success" id="startBtn" onclick="startCalibration()" disabled>
                    Start Calibration
                </button>
                <button class="btn-danger" id="stopBtn" onclick="stopCalibration()" disabled>
                    Stop
                </button>
            </div>

            <div class="progress-section hidden" id="progressSection">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
                </div>
                <div class="progress-stats">
                    <span id="phaseLabel">Phase: Random Search</span>
                    <span id="iterationLabel">Iteration: 0/0</span>
                    <span id="bestScoreLabel">Best Score: --</span>
                </div>

                <!-- Iteration Results Table -->
                <div id="iterationResultsContainer" class="hidden" style="margin-top: 15px;">
                    <h3 style="font-size: 13px; margin-bottom: 10px; color: #aaa;">Random Search Iterations</h3>
                    <div style="max-height: 400px; overflow-y: auto; background: #1a1a2e; border-radius: 4px; padding: 10px;">
                        <table id="iterationResultsTable" style="width: 100%; font-size: 11px; border-collapse: collapse;">
                            <thead style="position: sticky; top: 0; background: #2a2a4a; z-index: 1;">
                                <tr>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">#</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">Combined</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">Detection</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">Color</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">F1</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">Precision</th>
                                    <th style="padding: 8px 4px; text-align: center; border-bottom: 2px solid #444;">Recall</th>
                                </tr>
                            </thead>
                            <tbody id="iterationResultsBody">
                                <!-- Filled dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="log-output hidden" id="logOutput"></div>
        </div>

        <!-- Results -->
        <div class="panel hidden" id="resultsPanel">
            <h2><span class="step-number done">4</span> Results</h2>

            <div class="results-grid" id="resultsGrid">
                <!-- Filled dynamically -->
            </div>

            <div class="per-image-results" id="perImageResults">
                <h3>Per-Image Breakdown</h3>
                <!-- Filled dynamically -->
            </div>

            <h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 14px; color: #aaa;">
                Best Parameters (copy to detector)
            </h3>
            <div class="params-output" id="paramsOutput"></div>

            <div class="buttons-row" style="margin-top: 15px;">
                <button class="btn-primary" onclick="copyParams()">Copy Parameters</button>
                <button class="btn-secondary" onclick="applyToDetector()">Apply to Detector</button>
                <button class="btn-secondary" onclick="downloadParams()">Download JSON</button>
            </div>
        </div>

        <!-- Validation Results Visualization -->
        <div class="panel hidden" id="validationVisualization">
            <h2>Validation Results Visualization</h2>

            <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
                Detection results on validation set (images not used during training)
            </p>

            <div id="validationImagesContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
                <!-- Filled dynamically with validation images -->
            </div>
        </div>
        </div>

        <!-- Dataset Status Sidebar -->
        <div>
            <div class="panel" style="position: sticky; top: 20px;">
                <h2 style="font-size: 14px; margin-bottom: 15px;">Dataset Status</h2>

                <div id="datasetStatusTable" class="dataset-status-empty">
                    <div style="text-align: center; padding: 20px; color: #666; font-size: 13px;">
                        Load a dataset to see status
                    </div>
                </div>
            </div>
        </div>

        </div>
    </div>

    <script src="color-classifier.js"></script>
    <script src="calibrator.js"></script>
    <script>
        // State
        let cvReady = false;
        let datasetLoaded = false;
        let imagesLoaded = false;
        let lastResults = null;
        let iterationResults = [];
        let startingParams = null; // Optional starting parameters for optimization
        let bestScores = {
            combined: -Infinity,
            detection: -Infinity,
            color: -Infinity,
            f1: -Infinity,
            precision: -Infinity,
            recall: -Infinity
        };

        // DOM elements
        const datasetInput = document.getElementById('datasetInput');
        const imagesInput = document.getElementById('imagesInput');
        const datasetStatus = document.getElementById('datasetStatus');
        const imagesStatus = document.getElementById('imagesStatus');
        const loadImagesBtn = document.getElementById('loadImagesBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        const phaseLabel = document.getElementById('phaseLabel');
        const iterationLabel = document.getElementById('iterationLabel');
        const bestScoreLabel = document.getElementById('bestScoreLabel');
        const logOutput = document.getElementById('logOutput');
        const resultsPanel = document.getElementById('resultsPanel');
        const resultsGrid = document.getElementById('resultsGrid');
        const perImageResults = document.getElementById('perImageResults');
        const paramsOutput = document.getElementById('paramsOutput');

        function onOpenCvReady() {
            cv['onRuntimeInitialized'] = () => {
                cvReady = true;
                updateButtons();
            };
        }

        // Update dataset status table
        function updateDatasetStatusTable() {
            const table = document.getElementById('datasetStatusTable');

            if (!Calibrator.dataset || !Calibrator.dataset.images) {
                table.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666; font-size: 13px;">
                        Load a dataset to see status
                    </div>
                `;
                return;
            }

            const loadedCount = Calibrator.loadedImages.length;
            const totalCount = Calibrator.dataset.images.length;
            const allLoaded = loadedCount === totalCount;

            let html = `
                <div class="dataset-status-summary">
                    <div class="dataset-status-summary-value ${allLoaded ? 'complete' : ''}">${loadedCount} / ${totalCount}</div>
                    <div class="dataset-status-summary-label">Images Loaded</div>
                </div>
                <div class="dataset-status-table">
            `;

            Calibrator.dataset.images.forEach(img => {
                const isLoaded = Calibrator.loadedImages.some(loaded => loaded.filename === img.filename);
                const icon = isLoaded ?
                    '<div class="dataset-status-icon loaded">✓</div>' :
                    '<div class="dataset-status-icon missing">✗</div>';

                html += `
                    <div class="dataset-status-row">
                        <div class="dataset-status-filename" title="${img.filename}">${img.filename}</div>
                        ${icon}
                    </div>
                `;
            });

            html += '</div>';
            table.innerHTML = html;
        }

        function updateButtons() {
            // Get current state: NOT_READY, READY, RUNNING, CALIBRATED, STOPPED
            const state = Calibrator.state;

            // Check if all dataset images are loaded
            const allImagesLoaded = Calibrator.dataset &&
                                   Calibrator.dataset.images &&
                                   Calibrator.loadedImages.length === Calibrator.dataset.images.length &&
                                   Calibrator.loadedImages.length > 0;

            // Update Calibrator state if needed
            if (!cvReady || !datasetLoaded || !allImagesLoaded) {
                Calibrator.state = 'NOT_READY';
            } else if (state === 'NOT_READY') {
                Calibrator.state = 'READY';
            }

            loadImagesBtn.disabled = !datasetLoaded;
            startBtn.disabled = (Calibrator.state !== 'READY' && Calibrator.state !== 'CALIBRATED' && Calibrator.state !== 'STOPPED');
            stopBtn.disabled = (Calibrator.state !== 'RUNNING');

            // Update step indicators
            document.getElementById('step1').classList.toggle('done', datasetLoaded);
            document.getElementById('step2').classList.toggle('done', allImagesLoaded);

            // Mark images as loaded based on actual status
            imagesLoaded = allImagesLoaded;

            // Update status table
            updateDatasetStatusTable();
        }

        // Load dataset JSON
        datasetInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const result = Calibrator.loadDataset(text);

                if (result.success) {
                    datasetLoaded = true;
                    datasetStatus.textContent = `Loaded: ${result.imageCount} images`;
                    datasetStatus.className = 'file-status success';
                } else {
                    throw new Error(result.error);
                }
            } catch (err) {
                datasetLoaded = false;
                datasetStatus.textContent = `Error: ${err.message}`;
                datasetStatus.className = 'file-status error';
            }

            updateButtons();
        });

        // Load dataset from localStorage (saved by Dataset Editor)
        async function loadDatasetFromStorage() {
            const EDITOR_STORAGE_KEY = 'pokDatasetEditor';
            const saved = localStorage.getItem(EDITOR_STORAGE_KEY);

            if (!saved) {
                datasetStatus.textContent = 'No dataset in storage. Use Dataset Editor first.';
                datasetStatus.className = 'file-status error';
                return;
            }

            try {
                const storageData = JSON.parse(saved);

                // Load the dataset (annotations)
                const datasetJson = JSON.stringify(storageData.dataset);
                const result = Calibrator.loadDataset(datasetJson);

                if (!result.success) {
                    throw new Error(result.error);
                }

                datasetLoaded = true;
                datasetStatus.textContent = `Loaded: ${result.imageCount} images from storage`;
                datasetStatus.className = 'file-status success';

                // Also load the images from data URLs
                if (storageData.imageDataUrls && storageData.imageDataUrls.length > 0) {
                    imagesStatus.textContent = 'Loading images from storage...';
                    imagesStatus.className = 'file-status';

                    const loadedCount = await Calibrator.loadImagesFromDataUrls(storageData.imageDataUrls);
                    imagesLoaded = true;
                    imagesStatus.textContent = `Loaded: ${loadedCount} images from storage`;
                    imagesStatus.className = 'file-status success';
                }

                updateButtons();
            } catch (err) {
                datasetLoaded = false;
                datasetStatus.textContent = `Error: ${err.message}`;
                datasetStatus.className = 'file-status error';
                updateButtons();
            }
        }

        // Load image files
        imagesInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            try {
                imagesStatus.textContent = 'Loading images...';
                imagesStatus.className = 'file-status';

                const count = await Calibrator.loadImages(files);
                imagesLoaded = true;
                imagesStatus.textContent = `Loaded: ${count} images`;
                imagesStatus.className = 'file-status success';
            } catch (err) {
                imagesLoaded = false;
                imagesStatus.textContent = `Error: ${err.message}`;
                imagesStatus.className = 'file-status error';
            }

            updateButtons();
        });

        // Load starting parameters
        const startingParamsInput = document.getElementById('startingParamsInput');
        const startingParamsStatus = document.getElementById('startingParamsStatus');

        startingParamsInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                startingParamsStatus.textContent = 'Loading parameters...';
                startingParamsStatus.className = 'file-status';

                const text = await file.text();
                startingParams = JSON.parse(text);

                startingParamsStatus.textContent = `Loaded: ${file.name}`;
                startingParamsStatus.className = 'file-status success';

                console.log('Loaded starting parameters:', startingParams);
            } catch (err) {
                startingParams = null;
                startingParamsStatus.textContent = `Error: ${err.message}`;
                startingParamsStatus.className = 'file-status error';
            }
        });

        // Update dataset split summary display
        function updateDatasetSplitSummary() {
            if (Calibrator.trainingSet.length === 0 && Calibrator.validationSet.length === 0) {
                return;
            }

            const trainRatio = Calibrator.trainingSet.length / (Calibrator.trainingSet.length + Calibrator.validationSet.length);

            document.getElementById('datasetSplitSummary').classList.remove('hidden');

            // Training set summary
            const trainFilenames = Calibrator.trainingSet.map(img => img.filename).join(', ');
            document.getElementById('trainingSummary').innerHTML =
                `<strong>${Calibrator.trainingSet.length} image${Calibrator.trainingSet.length !== 1 ? 's' : ''}</strong> (${(trainRatio * 100).toFixed(0)}%)<br>` +
                `<div style="margin-top: 5px; color: #666;">${trainFilenames}</div>`;

            // Validation set summary
            const valFilenames = Calibrator.validationSet.map(img => img.filename).join(', ');
            document.getElementById('validationSummary').innerHTML =
                `<strong>${Calibrator.validationSet.length} image${Calibrator.validationSet.length !== 1 ? 's' : ''}</strong> (${((1 - trainRatio) * 100).toFixed(0)}%)<br>` +
                `<div style="margin-top: 5px; color: #666;">${valFilenames}</div>`;
        }

        // Add iteration result to table
        function addIterationResult(iteration, result, isBestCombined) {
            const tbody = document.getElementById('iterationResultsBody');
            const container = document.getElementById('iterationResultsContainer');

            // Show table on first iteration
            if (iteration === 1) {
                container.classList.remove('hidden');
                iterationResults = [];
                bestScores = {
                    combined: -Infinity,
                    detection: -Infinity,
                    color: -Infinity,
                    f1: -Infinity,
                    precision: -Infinity,
                    recall: -Infinity
                };
            }

            // Calculate average metrics
            const avgF1 = result.perImage.reduce((s, r) => s + r.f1, 0) / result.perImage.length;
            const avgPrecision = result.perImage.reduce((s, r) => s + r.precision, 0) / result.perImage.length;
            const avgRecall = result.perImage.reduce((s, r) => s + r.recall, 0) / result.perImage.length;

            const rowData = {
                iteration,
                combined: result.avgScore,
                detection: result.avgDetectionScore,
                color: result.avgColorScore,
                f1: avgF1,
                precision: avgPrecision,
                recall: avgRecall,
                isBestCombined
            };

            iterationResults.push(rowData);

            // Update best scores
            if (rowData.combined > bestScores.combined) bestScores.combined = rowData.combined;
            if (rowData.detection > bestScores.detection) bestScores.detection = rowData.detection;
            if (rowData.color > bestScores.color) bestScores.color = rowData.color;
            if (rowData.f1 > bestScores.f1) bestScores.f1 = rowData.f1;
            if (rowData.precision > bestScores.precision) bestScores.precision = rowData.precision;
            if (rowData.recall > bestScores.recall) bestScores.recall = rowData.recall;

            // Rebuild entire table to update highlighting
            updateIterationResultsTable();
        }

        // Update iteration results table with proper highlighting
        function updateIterationResultsTable() {
            const tbody = document.getElementById('iterationResultsBody');
            tbody.innerHTML = '';

            iterationResults.forEach((row, idx) => {
                const tr = document.createElement('tr');
                if (row.isBestCombined) {
                    tr.className = 'iteration-row-best-combined';
                }

                const cells = [
                    row.iteration,
                    row.combined.toFixed(2),
                    row.detection.toFixed(2),
                    row.color.toFixed(2),
                    (row.f1 * 100).toFixed(1) + '%',
                    (row.precision * 100).toFixed(1) + '%',
                    (row.recall * 100).toFixed(1) + '%'
                ];

                const scores = [
                    null, // iteration number
                    row.combined,
                    row.detection,
                    row.color,
                    row.f1,
                    row.precision,
                    row.recall
                ];

                const bestValues = [
                    null,
                    bestScores.combined,
                    bestScores.detection,
                    bestScores.color,
                    bestScores.f1,
                    bestScores.precision,
                    bestScores.recall
                ];

                cells.forEach((cell, i) => {
                    const td = document.createElement('td');
                    td.textContent = cell;

                    // Highlight if this is the best value in this column
                    if (i > 0 && scores[i] !== null && Math.abs(scores[i] - bestValues[i]) < 0.001) {
                        td.className = 'iteration-cell-best';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Auto-scroll to bottom
            const container = tbody.closest('div[style*="overflow-y"]');
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        }

        // Start calibration
        async function startCalibration() {
            if (!cvReady || !datasetLoaded || !imagesLoaded) return;

            const randomIter = parseInt(document.getElementById('randomIterations').value);
            const localIter = parseInt(document.getElementById('localIterations').value);
            const matchThreshold = parseInt(document.getElementById('matchThreshold').value);
            const trainRatio = parseFloat(document.getElementById('trainRatio').value) / 100;

            Calibrator.matchDistanceThreshold = matchThreshold;

            progressSection.classList.remove('hidden');
            logOutput.classList.remove('hidden');
            logOutput.innerHTML = '';
            resultsPanel.classList.add('hidden');
            document.getElementById('validationVisualization').classList.add('hidden');
            document.getElementById('iterationResultsContainer').classList.add('hidden');

            // Reset iteration tracking
            iterationResults = [];
            bestScores = {
                combined: -Infinity,
                detection: -Infinity,
                color: -Infinity,
                f1: -Infinity,
                precision: -Infinity,
                recall: -Infinity
            };

            // Update buttons immediately to reflect running state
            updateButtons();

            try {
                let lastBestCombined = -Infinity;

                const results = await Calibrator.optimize({
                    randomIterations: randomIter,
                    localIterations: localIter,
                    trainRatio: trainRatio,
                    startingParams: startingParams,
                    onProgress: (progress) => {
                        // Update split summary after dataset is split (first progress callback)
                        if (progress.iteration === 0 && (progress.phase === 'random' || progress.phase === 'local')) {
                            updateDatasetSplitSummary();
                        }

                        // If starting params provided, skip random search in progress calculation
                        const effectiveRandomIter = startingParams ? 0 : randomIter;
                        const total = progress.phase === 'random' ? randomIter : localIter;
                        const offset = progress.phase === 'local' ? effectiveRandomIter : 0;
                        const pct = Math.round(((offset + progress.iteration) / (effectiveRandomIter + localIter)) * 100);

                        progressBar.style.width = pct + '%';
                        progressBar.textContent = pct + '%';

                        phaseLabel.textContent = `Phase: ${progress.phase === 'random' ? 'Random Search' : 'Local Refinement'}`;
                        iterationLabel.textContent = `Iteration: ${progress.iteration}/${total}`;
                        bestScoreLabel.textContent = `Best Score: ${progress.bestScore.toFixed(2)}`;

                        // Track iteration results during random search
                        if (progress.phase === 'random' && progress.currentResult) {
                            const isBestCombined = progress.currentScore > lastBestCombined;
                            if (isBestCombined) {
                                lastBestCombined = progress.currentScore;
                            }
                            addIterationResult(progress.iteration, progress.currentResult, isBestCombined);
                        }
                    },
                    onBestFound: (best) => {
                        const logEntry = document.createElement('div');
                        logEntry.className = 'log-entry best';
                        logEntry.textContent = `New best: ${best.score.toFixed(2)} (F1: ${(best.details.perImage[0]?.f1 * 100 || 0).toFixed(1)}%, Color: ${(best.details.perImage[0]?.colorAccuracy * 100 || 0).toFixed(1)}%)`;
                        logOutput.appendChild(logEntry);
                        logOutput.scrollTop = logOutput.scrollHeight;
                    }
                });

                lastResults = results;
                showResults(results);
            } catch (err) {
                console.error('Calibration error:', err);
                alert('Calibration error: ' + err.message);
            } finally {
                // Ensure button state is updated when calibration finishes
                updateButtons();
            }
        }

        // Stop calibration
        function stopCalibration() {
            Calibrator.stop();
            // Update buttons after stopping
            setTimeout(() => updateButtons(), 100);
        }

        // Draw detections and annotations on canvas
        function drawValidationResult(canvas, image, detections, annotations, metrics) {
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');

            // Draw image
            ctx.drawImage(image, 0, 0);

            // Draw annotations (ground truth) - green circles
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 2;
            annotations.forEach(ann => {
                ctx.beginPath();
                ctx.arc(ann.x, ann.y, 15, 0, 2 * Math.PI);
                ctx.stroke();

                // Small label
                ctx.fillStyle = '#2ecc71';
                ctx.font = 'bold 10px sans-serif';
                ctx.fillText('GT', ann.x - 8, ann.y - 20);
            });

            // Draw detections - colored by match status
            detections.forEach((det, idx) => {
                const color = det.color === 'red' ? 'rgba(231, 76, 60, 0.3)' :
                             det.color === 'blue' ? 'rgba(74, 144, 217, 0.3)' :
                             'rgba(149, 165, 166, 0.3)';

                // Semi-transparent fill
                ctx.beginPath();
                ctx.arc(det.x, det.y, det.radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                // Border - use different color if matched correctly
                const borderColor = det.color === 'red' ? '#e74c3c' :
                                   det.color === 'blue' ? '#4a90d9' : '#95a5a6';
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // Show validation visualization
        function showValidationVisualization(results) {
            if (!results.validationResult || Calibrator.validationSet.length === 0) {
                return;
            }

            const container = document.getElementById('validationImagesContainer');
            container.innerHTML = '';

            Calibrator.validationSet.forEach((entry, idx) => {
                const detections = Calibrator.detectWithParams(entry.image, results.bestParams);
                const score = Calibrator.calculateScore(detections, entry.annotations);

                const card = document.createElement('div');
                card.className = 'validation-image-card';

                const canvas = document.createElement('canvas');
                canvas.className = 'validation-canvas';
                drawValidationResult(canvas, entry.image, detections, entry.annotations, score);

                const f1Class = score.f1 >= 0.8 ? 'good' : score.f1 < 0.5 ? 'bad' : '';
                const colorClass = score.colorAccuracy >= 0.8 ? 'good' : score.colorAccuracy < 0.5 ? 'bad' : '';

                card.innerHTML = `
                    <h4>${entry.filename}</h4>
                    <div class="validation-canvas-container"></div>
                    <div class="validation-metrics">
                        <div class="validation-metric">
                            <div class="validation-metric-label">F1 Score</div>
                            <div class="validation-metric-value ${f1Class}">${(score.f1 * 100).toFixed(1)}%</div>
                        </div>
                        <div class="validation-metric">
                            <div class="validation-metric-label">Color Accuracy</div>
                            <div class="validation-metric-value ${colorClass}">${(score.colorAccuracy * 100).toFixed(1)}%</div>
                        </div>
                        <div class="validation-metric">
                            <div class="validation-metric-label">Detections</div>
                            <div class="validation-metric-value">${score.truePositives} / ${entry.annotations.length}</div>
                        </div>
                        <div class="validation-metric">
                            <div class="validation-metric-label">False Positives</div>
                            <div class="validation-metric-value ${score.falsePositives > 0 ? 'bad' : ''}">${score.falsePositives}</div>
                        </div>
                        <div class="validation-metric">
                            <div class="validation-metric-label">False Negatives</div>
                            <div class="validation-metric-value ${score.falseNegatives > 0 ? 'bad' : ''}">${score.falseNegatives}</div>
                        </div>
                        <div class="validation-metric">
                            <div class="validation-metric-label">Avg Pos Error</div>
                            <div class="validation-metric-value">${score.avgPositionError.toFixed(1)}px</div>
                        </div>
                    </div>
                `;

                card.querySelector('.validation-canvas-container').appendChild(canvas);
                container.appendChild(card);
            });

            document.getElementById('validationVisualization').classList.remove('hidden');
        }

        // Show results
        function showResults(results) {
            if (!results.bestParams) {
                alert('No valid parameters found');
                return;
            }

            resultsPanel.classList.remove('hidden');

            // Evaluate best params one more time for detailed results
            const evaluation = Calibrator.evaluateParams(results.bestParams);

            // Summary cards
            const avgMetrics = {
                f1: evaluation.perImage.reduce((s, r) => s + r.f1, 0) / evaluation.perImage.length,
                colorAccuracy: evaluation.perImage.reduce((s, r) => s + r.colorAccuracy, 0) / evaluation.perImage.length,
                precision: evaluation.perImage.reduce((s, r) => s + r.precision, 0) / evaluation.perImage.length,
                recall: evaluation.perImage.reduce((s, r) => s + r.recall, 0) / evaluation.perImage.length,
                avgPositionError: evaluation.perImage.reduce((s, r) => s + r.avgPositionError, 0) / evaluation.perImage.length
            };

            resultsGrid.innerHTML = `
                <div class="result-card highlight">
                    <div class="value">${(avgMetrics.f1 * 100).toFixed(1)}%</div>
                    <div class="label">F1 Score</div>
                </div>
                <div class="result-card">
                    <div class="value">${(avgMetrics.colorAccuracy * 100).toFixed(1)}%</div>
                    <div class="label">Color Accuracy</div>
                </div>
                <div class="result-card">
                    <div class="value">${(avgMetrics.precision * 100).toFixed(1)}%</div>
                    <div class="label">Precision</div>
                </div>
                <div class="result-card">
                    <div class="value">${(avgMetrics.recall * 100).toFixed(1)}%</div>
                    <div class="label">Recall</div>
                </div>
                <div class="result-card">
                    <div class="value">${avgMetrics.avgPositionError.toFixed(1)}px</div>
                    <div class="label">Avg Position Error</div>
                </div>
                <div class="result-card">
                    <div class="value">${results.iterations}</div>
                    <div class="label">Iterations</div>
                </div>
            `;

            // Per-image breakdown
            let perImageHtml = '<h3>Per-Image Breakdown</h3>';
            evaluation.perImage.forEach(img => {
                perImageHtml += `
                    <div class="image-result-row">
                        <span class="filename">${img.filename}</span>
                        <div class="metrics">
                            <span class="metric">F1: <span class="metric-value">${(img.f1 * 100).toFixed(1)}%</span></span>
                            <span class="metric">Color: <span class="metric-value">${(img.colorAccuracy * 100).toFixed(1)}%</span></span>
                            <span class="metric">TP: <span class="metric-value">${img.truePositives}</span></span>
                            <span class="metric">FP: <span class="metric-value">${img.falsePositives}</span></span>
                            <span class="metric">FN: <span class="metric-value">${img.falseNegatives}</span></span>
                        </div>
                    </div>
                `;
            });
            perImageResults.innerHTML = perImageHtml;

            // Parameters output
            paramsOutput.textContent = JSON.stringify(results.bestParams, null, 2);

            // Show validation visualization
            showValidationVisualization(results);
        }

        // Copy parameters to clipboard
        function copyParams() {
            if (!lastResults?.bestParams) return;
            navigator.clipboard.writeText(JSON.stringify(lastResults.bestParams, null, 2));
            alert('Parameters copied to clipboard!');
        }

        // Apply to detector (saves to localStorage)
        function applyToDetector() {
            if (!lastResults?.bestParams) return;
            localStorage.setItem('pokDetectorParams', JSON.stringify(lastResults.bestParams));
            // Mark source as calibrated so detector shows the right indicator
            localStorage.setItem('pokDetectorParamsSource', 'calibrated');
            alert('Calibrated parameters saved! Open detector to use them.');
        }

        // Download parameters as JSON
        function downloadParams() {
            if (!lastResults?.bestParams) return;
            const blob = new Blob([JSON.stringify(lastResults.bestParams, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'calibrated-params.json';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>
</body>
</html>
