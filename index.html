<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POK Score Counter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f0f0f0;
            transition: background-color 0.3s;
        }

        body.red-turn {
            background: #d32f2f;
        }

        body.blue-turn {
            background: #1976d2;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 95vh;
        }

        .top-section {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            flex: 1;
        }

        .main-score-center {
            text-align: center;
            font-size: 64px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .main-score-center .red {
            color: #d32f2f;
        }

        .main-score-center .blue {
            color: #1976d2;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            text-align: center;
            font-size: 20px;
            margin-bottom: 5px;
        }

        .scoreboard {
            text-align: center;
            padding: 30px 20px;
            border-radius: 8px;
            background: #fafafa;
        }

        .main-score {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .main-score .red {
            color: #d32f2f;
        }

        .main-score .blue {
            color: #1976d2;
        }

        .round-score {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .round-score .red {
            color: #d32f2f;
        }

        .round-score .blue {
            color: #1976d2;
        }

        .poks-remaining {
            font-size: 16px;
            font-style: italic;
            color: #999;
        }

        .table-container {
            background: #c9985a;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .outer-zone {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: pointer;
            z-index: 0;
        }

        .outer-zone:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .table {
            background: #e4c9a0;
            border: 3px solid #2c1810;
            position: relative;
            aspect-ratio: 1.5/1;
            width: 100%;
            max-width: 800px;
            z-index: 1;
        }

        .table-inner {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
        }

        .side {
            flex: 1;
            position: relative;
            display: flex;
        }

        .center-circle {
            width: 200px;
            height: 200px;
            border: 3px solid #2c1810;
            border-radius: 50%;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e4c9a0;
            pointer-events: none;
            z-index: 1;
        }

        .center-circle svg {
            width: 100%;
            height: 100%;
        }

        .column {
            flex: 1;
            border-right: 3px solid #2c1810;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .column.zero-column {
            flex: 2;
        }

        .column:last-child {
            border-right: none;
        }

        .side.right .column {
            border-left: 3px solid #2c1810;
            border-right: none;
        }

        .side.right .column:first-child {
            border-left: none;
        }

        .zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }

        .zone:hover {
            background: #d4b890;
        }

        .zone-label {
            font-size: 48px;
            font-weight: normal;
            color: #2c1810;
        }

        .circle-zone {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 3px solid #2c1810;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #e4c9a0;
            transition: background-color 0.2s;
        }

        .circle-zone:hover {
            background: #d4b890;
        }

        .circle-zone.top {
            top: 20px;
        }

        .circle-zone.bottom {
            bottom: 20px;
        }

        .side.left .circle-zone {
            left: 50%;
            transform: translateX(-50%);
        }

        .side.right .circle-zone {
            left: 20px;
        }

        .pok {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            z-index: 100;
            cursor: move;
        }

        .pok.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .pok.red {
            background: #d32f2f;
        }

        .pok.blue {
            background: #1976d2;
        }

        .pok.low-score.red {
            background: linear-gradient(135deg, #d32f2f 50%, #888 50%);
        }

        .pok.low-score.blue {
            background: linear-gradient(135deg, #1976d2 50%, #888 50%);
        }

        button {
            padding: 12px 24px;
            margin: 10px 0;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #333;
            color: white;
            transition: background 0.2s;
            width: 100%;
        }

        button:hover {
            background: #555;
        }

        button:active {
            transform: scale(0.98);
        }

        .start-selector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2000;
            display: flex;
        }

        .start-half {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.3s;
            font-size: 64px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .start-half:hover {
            opacity: 0.9;
        }

        .start-half.red {
            background: #d32f2f;
        }

        .start-half.blue {
            background: #1976d2;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .modal.show {
            display: flex;
        }

        .modal.red-bg {
            background: #d32f2f;
        }

        .modal.blue-bg {
            background: #1976d2;
        }

        .modal.tie-bg {
            background: #666;
        }

        .modal-content {
            text-align: center;
            color: white;
            width: 100%;
            padding: 40px;
        }

        .modal-content .winner {
            font-size: 96px;
            font-weight: bold;
            margin-bottom: 40px;
            color: white;
        }

        .modal-content .round-scores {
            font-size: 48px;
            margin: 30px 0;
            color: white;
        }

        .modal-content .total-scores {
            font-size: 36px;
            margin-top: 40px;
            color: rgba(255, 255, 255, 0.9);
        }

        .modal-content .continue-hint {
            font-size: 24px;
            margin-top: 60px;
            color: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-score-center">
            <span class="red" id="mainRedTotal">0</span> - <span class="blue" id="mainBlueTotal">0</span>
        </div>

        <div class="top-section">
            <div class="left-panel">
                <h1>POK Score Counter</h1>

                <div class="scoreboard" id="scoreboard">
                    <div class="round-score">
                        <span class="red" id="redRound">0</span> - <span class="blue" id="blueRound">0</span>
                    </div>
                    <div class="poks-remaining">
                        <span id="redPoks">5</span> - <span id="bluePoks">5</span>
                    </div>
                </div>

                <div id="nextPlayer" style="text-align: center; font-size: 18px; font-weight: bold; margin-top: auto; padding: 20px;"></div>

                <div id="startSelector" class="start-selector">
                    <div class="start-half red" onclick="startGame('red')">
                        RED
                    </div>
                    <div class="start-half blue" onclick="startGame('blue')">
                        BLUE
                    </div>
                </div>
            </div>

            <div class="table-container" id="tableContainer">
            <div class="outer-zone" id="outerZone" onclick="placePokOuter(event)" ondrop="handlePokDrop(event, null, true)" ondragover="event.preventDefault()"></div>
            <div class="table">
                <div class="table-inner">
                    <!-- Left side -->
                    <div class="side left">
                        <div class="column">
                            <div class="zone" data-zone="3" data-low="2" data-high="3" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">3</div>
                            </div>
                        </div>
                        <div class="column">
                            <div class="zone" data-zone="2" data-low="1" data-high="2" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">2</div>
                            </div>
                        </div>
                        <div class="column">
                            <div class="zone" data-zone="1" data-low="0" data-high="1" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">1</div>
                            </div>
                            <div class="circle-zone top" data-zone="4" data-low="1" data-high="4" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">4</div>
                            </div>
                            <div class="circle-zone bottom" data-zone="5" data-low="1" data-high="5" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">5</div>
                            </div>
                        </div>
                        <div class="column zero-column">
                            <div class="zone" data-zone="0" data-low="0" data-high="0" onclick="placePok(this, event)" ondrop="handlePokDrop(event, this)" ondragover="event.preventDefault()">
                                <div class="zone-label">0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Center POK logo -->
                    <div class="center-circle">
                        <svg viewBox="0 0 200 200">
                            <circle cx="100" cy="100" r="90" fill="none" stroke="#2c1810" stroke-width="2"/>
                            <circle cx="100" cy="40" r="4" fill="#2c1810"/>
                            <circle cx="130" cy="50" r="4" fill="#2c1810"/>
                            <circle cx="155" cy="75" r="4" fill="#2c1810"/>
                            <circle cx="160" cy="100" r="4" fill="#2c1810"/>
                            <circle cx="155" cy="125" r="4" fill="#2c1810"/>
                            <circle cx="130" cy="150" r="4" fill="#2c1810"/>
                            <circle cx="100" cy="160" r="4" fill="#2c1810"/>
                            <circle cx="70" cy="150" r="4" fill="#2c1810"/>
                            <circle cx="45" cy="125" r="4" fill="#2c1810"/>
                            <circle cx="40" cy="100" r="4" fill="#2c1810"/>
                            <circle cx="45" cy="75" r="4" fill="#2c1810"/>
                            <circle cx="70" cy="50" r="4" fill="#2c1810"/>
                            <line x1="70" y1="100" x2="130" y2="100" stroke="#2c1810" stroke-width="2"/>
                            <line x1="100" y1="70" x2="100" y2="130" stroke="#2c1810" stroke-width="2"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

        <div id="roundModal" class="modal" onclick="continueToNextRound()">
            <div class="modal-content">
                <div class="winner" id="modalWinner"></div>
                <div class="round-scores" id="modalRoundScores"></div>
                <div class="total-scores" id="modalTotalScores"></div>
            </div>
        </div>

    <script>
        // ============================================
        // Constants
        // ============================================
        const PLAYER_ID = {
            RED: 'red',
            BLUE: 'blue'
        };

        const PLAYER_COLOR = {
            [PLAYER_ID.RED]: '#d32f2f',
            [PLAYER_ID.BLUE]: '#1976d2'
        };

        const PLAYER_CLASS = {
            [PLAYER_ID.RED]: 'red-turn',
            [PLAYER_ID.BLUE]: 'blue-turn'
        };

        const EVENT_TYPES = {
            GAME_STARTED: 'GAME_STARTED',
            GAME_RESET: 'GAME_RESET',
            ROUND_STARTED: 'ROUND_STARTED',
            ROUND_ENDED: 'ROUND_ENDED',
            POK_PLACED: 'POK_PLACED',
            POK_MOVED: 'POK_MOVED',
            POK_REMOVED: 'POK_REMOVED',
            PLAYER_SWITCHED: 'PLAYER_SWITCHED'
        };

        // ============================================
        // Event System Classes
        // ============================================

        class GameEvent {
            constructor(type, data) {
                this.type = type;
                this.timestamp = Date.now();
                this.data = data;
            }
        }

        class EventLog {
            constructor() {
                this.events = [];
            }

            record(event) {
                this.events.push(event);
                const time = new Date(event.timestamp).toLocaleTimeString();
                console.log(`[${time}] ${event.type}:`, event.data);
            }

            getAll() {
                return [...this.events];
            }

            clear() {
                this.events = [];
                console.log('Event log cleared');
            }

            export() {
                return JSON.stringify(this.events, null, 2);
            }

            printSummary() {
                console.log('=== Event Log Summary ===');
                console.log(`Total events: ${this.events.length}`);
                const eventCounts = {};
                this.events.forEach(e => {
                    eventCounts[e.type] = (eventCounts[e.type] || 0) + 1;
                });
                console.table(eventCounts);
            }
        }

        // ============================================
        // State Machine
        // ============================================

        class GameStateMachine {
            constructor() {
                this.currentState = 'GAME_NOT_STARTED';

                this.transitions = {
                    'GAME_NOT_STARTED': ['GAME_STARTED'],
                    'GAME_STARTED': ['PLAYER_TURN'],
                    'PLAYER_TURN': ['POK_PLACED', 'ROUND_COMPLETE'],
                    'POK_PLACED': ['PLAYER_TURN', 'ROUND_COMPLETE'],
                    'ROUND_COMPLETE': ['ROUND_ENDED'],
                    'ROUND_ENDED': ['PLAYER_TURN', 'GAME_COMPLETE'],
                    'GAME_COMPLETE': ['GAME_NOT_STARTED']
                };
            }

            canTransition(eventType) {
                return this.transitions[this.currentState]?.includes(eventType) || false;
            }

            transition(newState) {
                console.log(`State: ${this.currentState} â†’ ${newState}`);
                this.currentState = newState;
            }

            setState(state) {
                this.currentState = state;
            }

            getState() {
                return this.currentState;
            }
        }

        // ============================================
        // Service Classes
        // ============================================

        class RulesEngine {
            canPlacePok(round, playerId) {
                if (!round) return false;
                if (round.currentPlayerId !== playerId) return false;

                const remaining = playerId === PLAYER_ID.RED
                    ? round.redPoksRemaining
                    : round.bluePoksRemaining;

                return remaining > 0;
            }

            getNextPlayer(round) {
                if (round.redPoksRemaining === 0 && round.bluePoksRemaining > 0) {
                    return PLAYER_ID.BLUE;
                }
                if (round.bluePoksRemaining === 0 && round.redPoksRemaining > 0) {
                    return PLAYER_ID.RED;
                }

                if (round.redPoksRemaining > 0 && round.bluePoksRemaining > 0) {
                    if (round.scores.red < round.scores.blue) {
                        return PLAYER_ID.RED;
                    } else if (round.scores.blue < round.scores.red) {
                        return PLAYER_ID.BLUE;
                    } else {
                        return round.currentPlayerId === PLAYER_ID.RED
                            ? PLAYER_ID.BLUE
                            : PLAYER_ID.RED;
                    }
                }

                return round.currentPlayerId;
            }

            getRoundStarter(previousRound) {
                if (!previousRound) return null;

                if (previousRound.scores.winner === 'tie') {
                    return previousRound.startingPlayerId === PLAYER_ID.RED
                        ? PLAYER_ID.BLUE
                        : PLAYER_ID.RED;
                }

                return previousRound.scores.winner;
            }

            shouldEndGame(game) {
                return game.players.red.totalScore >= game.winningScore ||
                       game.players.blue.totalScore >= game.winningScore;
            }

            calculateRoundWinner(round) {
                const diff = Math.abs(round.scores.red - round.scores.blue);

                if (round.scores.red > round.scores.blue) {
                    return { winner: PLAYER_ID.RED, pointsEarned: diff };
                } else if (round.scores.blue > round.scores.red) {
                    return { winner: PLAYER_ID.BLUE, pointsEarned: diff };
                } else {
                    return { winner: 'tie', pointsEarned: 0 };
                }
            }
        }

        class ScoringService {
            constructor() {
                this.boundaryThreshold = 10;
            }

            calculateZoneScore(zone, clickPosition, zoneRect) {
                const low = parseInt(zone.dataset.low);
                const high = parseInt(zone.dataset.high);

                if (low === high) {
                    return { points: high, isHigh: true };
                }

                const isNearBoundary = clickPosition.x >= zoneRect.width - this.boundaryThreshold;

                return {
                    points: isNearBoundary ? low : high,
                    isHigh: !isNearBoundary
                };
            }
        }

        class PokService {
            constructor() {
                this.pokIdCounter = 0;
                this.pokElements = new Map();
            }

            generatePokId() {
                return `pok-${this.pokIdCounter++}`;
            }

            createPok(playerId, points, position, zoneId, isHighScore) {
                const pokId = this.generatePokId();
                const pok = new Pok(pokId, playerId, points, position.x, position.y, zoneId, isHighScore);
                return pok;
            }

            createPokElement(pok) {
                const el = document.createElement('div');
                el.className = `pok ${pok.playerId}`;
                if (!pok.isHighScore) {
                    el.classList.add('low-score');
                }
                el.textContent = pok.points;
                el.style.left = `${pok.position.x}px`;
                el.style.top = `${pok.position.y}px`;
                el.style.transform = 'translate(-50%, -50%)';
                return el;
            }

            attachPokToZone(pokElement, zoneElement) {
                zoneElement.appendChild(pokElement);
            }

            removePokElement(pokId) {
                const pokElement = this.pokElements.get(pokId);
                if (pokElement) {
                    pokElement.remove();
                    this.pokElements.delete(pokId);
                }
            }

            setPokElement(pokId, element) {
                this.pokElements.set(pokId, element);
            }

            getPokElement(pokId) {
                return this.pokElements.get(pokId);
            }

            clearAllPokElements() {
                document.querySelectorAll('.pok').forEach(pok => pok.remove());
                this.pokElements.clear();
            }

            reset() {
                this.pokIdCounter = 0;
                this.clearAllPokElements();
            }
        }

        class UIService {
            constructor() {
                this.domElements = null;
            }

            init() {
                this.domElements = {
                    startSelector: document.getElementById('startSelector'),
                    nextPlayer: document.getElementById('nextPlayer'),
                    tableContainer: document.getElementById('tableContainer'),
                    mainRedTotal: document.getElementById('mainRedTotal'),
                    mainBlueTotal: document.getElementById('mainBlueTotal'),
                    redRound: document.getElementById('redRound'),
                    blueRound: document.getElementById('blueRound'),
                    redPoks: document.getElementById('redPoks'),
                    bluePoks: document.getElementById('bluePoks'),
                    roundModal: document.getElementById('roundModal'),
                    modalWinner: document.getElementById('modalWinner'),
                    modalRoundScores: document.getElementById('modalRoundScores'),
                    modalTotalScores: document.getElementById('modalTotalScores')
                };
            }

            updateScores(game) {
                const round = game.getCurrentRound();

                this.domElements.mainRedTotal.textContent = game.players.red.totalScore;
                this.domElements.mainBlueTotal.textContent = game.players.blue.totalScore;

                if (round) {
                    this.domElements.redRound.textContent = round.scores.red;
                    this.domElements.blueRound.textContent = round.scores.blue;
                    this.domElements.redPoks.textContent = round.redPoksRemaining;
                    this.domElements.bluePoks.textContent = round.bluePoksRemaining;
                } else {
                    this.domElements.redRound.textContent = 0;
                    this.domElements.blueRound.textContent = 0;
                    this.domElements.redPoks.textContent = game.poksPerPlayer;
                    this.domElements.bluePoks.textContent = game.poksPerPlayer;
                }
            }

            updateCurrentPlayer(round) {
                if (!round) return;

                const currentPlayerId = round.currentPlayerId;

                document.body.classList.remove(PLAYER_CLASS[PLAYER_ID.RED], PLAYER_CLASS[PLAYER_ID.BLUE]);

                if (currentPlayerId === PLAYER_ID.RED) {
                    document.body.classList.add(PLAYER_CLASS[PLAYER_ID.RED]);
                } else if (currentPlayerId === PLAYER_ID.BLUE) {
                    document.body.classList.add(PLAYER_CLASS[PLAYER_ID.BLUE]);
                }

                if (this.domElements.nextPlayer) {
                    if (currentPlayerId === PLAYER_ID.RED) {
                        this.domElements.nextPlayer.textContent = 'Next player: red';
                        this.domElements.nextPlayer.style.color = PLAYER_COLOR[PLAYER_ID.RED];
                    } else if (currentPlayerId === PLAYER_ID.BLUE) {
                        this.domElements.nextPlayer.textContent = 'Next player: blue';
                        this.domElements.nextPlayer.style.color = PLAYER_COLOR[PLAYER_ID.BLUE];
                    }
                }
            }

            showStartSelector() {
                this.domElements.startSelector.style.display = 'flex';
            }

            hideStartSelector() {
                this.domElements.startSelector.style.display = 'none';
            }

            showRoundModal(winnerText, redScore, blueScore, redTotal, blueTotal, bgClass) {
                this.domElements.modalWinner.textContent = winnerText;
                this.domElements.modalRoundScores.textContent = `Round: Red ${redScore} - Blue ${blueScore}`;
                this.domElements.modalTotalScores.textContent = `Total: Red ${redTotal} - Blue ${blueTotal}`;

                this.domElements.roundModal.classList.remove('red-bg', 'blue-bg', 'tie-bg');
                this.domElements.roundModal.classList.add(bgClass, 'show');
            }

            hideRoundModal() {
                this.domElements.roundModal.classList.remove('show');
            }
        }

        // ============================================
        // Classes
        // ============================================

        class Player {
            constructor(id) {
                this.id = id;
                this.totalScore = 0;
            }

            addScore(points) {
                this.totalScore += points;
            }

            resetScore() {
                this.totalScore = 0;
            }
        }

        class Pok {
            constructor(id, playerId, points, x, y, zoneId, isHighScore) {
                this.id = id;
                this.playerId = playerId;
                this.points = points;
                this.position = { x, y };
                this.zoneId = zoneId;
                this.isHighScore = isHighScore;
            }

            updatePosition(x, y) {
                this.position.x = x;
                this.position.y = y;
            }

            updateScore(points, isHighScore) {
                this.points = points;
                this.isHighScore = isHighScore;
            }

            updateZone(zoneId) {
                this.zoneId = zoneId;
            }
        }

        class RoundScore {
            constructor(red = 0, blue = 0) {
                this.red = red;
                this.blue = blue;
                this.winner = 'tie';
                this.pointDifference = 0;
                this.updateWinner();
            }

            updateWinner() {
                const diff = Math.abs(this.red - this.blue);
                this.pointDifference = diff;

                if (this.red > this.blue) {
                    this.winner = 'red';
                } else if (this.blue > this.red) {
                    this.winner = 'blue';
                } else {
                    this.winner = 'tie';
                }
            }

            addPoints(playerId, points) {
                if (playerId === PLAYER_ID.RED) {
                    this.red += points;
                } else if (playerId === PLAYER_ID.BLUE) {
                    this.blue += points;
                }
                this.updateWinner();
            }
        }

        class Round {
            constructor(roundNumber, startingPlayerId, poksPerPlayer) {
                this.roundNumber = roundNumber;
                this.startingPlayerId = startingPlayerId;
                this.currentPlayerId = startingPlayerId;
                this.poksPlaced = [];
                this.redPoksRemaining = poksPerPlayer;
                this.bluePoksRemaining = poksPerPlayer;
                this.scores = new RoundScore(0, 0);
                this.isComplete = false;
                this.lastPlacedPokId = null;
            }

            addPok(pok) {
                this.poksPlaced.push(pok);
                this.scores.addPoints(pok.playerId, pok.points);
                this.decrementPoksRemaining(pok.playerId);
                this.lastPlacedPokId = pok.id;
            }

            removePok(pokId) {
                const index = this.poksPlaced.findIndex(p => p.id === pokId);
                if (index === -1) return null;

                const pok = this.poksPlaced[index];
                this.scores.addPoints(pok.playerId, -pok.points);
                this.incrementPoksRemaining(pok.playerId);
                this.poksPlaced.splice(index, 1);

                if (pokId === this.lastPlacedPokId) {
                    this.lastPlacedPokId = null;
                }

                return pok;
            }

            getPokById(pokId) {
                return this.poksPlaced.find(p => p.id === pokId);
            }

            decrementPoksRemaining(playerId) {
                if (playerId === PLAYER_ID.RED) {
                    this.redPoksRemaining--;
                } else if (playerId === PLAYER_ID.BLUE) {
                    this.bluePoksRemaining--;
                }
            }

            incrementPoksRemaining(playerId) {
                if (playerId === PLAYER_ID.RED) {
                    this.redPoksRemaining++;
                } else if (playerId === PLAYER_ID.BLUE) {
                    this.bluePoksRemaining++;
                }
            }

            isRoundComplete() {
                return this.redPoksRemaining === 0 && this.bluePoksRemaining === 0;
            }

            switchPlayer() {
                if (this.redPoksRemaining === 0 && this.bluePoksRemaining > 0) {
                    this.currentPlayerId = PLAYER_ID.BLUE;
                } else if (this.bluePoksRemaining === 0 && this.redPoksRemaining > 0) {
                    this.currentPlayerId = PLAYER_ID.RED;
                } else if (this.redPoksRemaining > 0 && this.bluePoksRemaining > 0) {
                    if (this.scores.red < this.scores.blue) {
                        this.currentPlayerId = PLAYER_ID.RED;
                    } else if (this.scores.blue < this.scores.red) {
                        this.currentPlayerId = PLAYER_ID.BLUE;
                    } else {
                        this.currentPlayerId = this.currentPlayerId === PLAYER_ID.RED ? PLAYER_ID.BLUE : PLAYER_ID.RED;
                    }
                }
            }
        }

        class Game {
            constructor() {
                this.isStarted = false;
                this.winningScore = 21;
                this.poksPerPlayer = 5;
                this.players = {
                    red: new Player(PLAYER_ID.RED),
                    blue: new Player(PLAYER_ID.BLUE)
                };
                this.rounds = [];
                this.currentRoundIndex = -1;
            }

            startNewGame(startingPlayerId) {
                this.isStarted = true;
                const round = new Round(0, startingPlayerId, this.poksPerPlayer);
                this.rounds.push(round);
                this.currentRoundIndex = 0;
            }

            getCurrentRound() {
                if (this.currentRoundIndex === -1) return null;
                return this.rounds[this.currentRoundIndex];
            }

            startNewRound(startingPlayerId) {
                const newRoundNumber = this.rounds.length;
                const round = new Round(newRoundNumber, startingPlayerId, this.poksPerPlayer);
                this.rounds.push(round);
                this.currentRoundIndex = newRoundNumber;
            }

            reset() {
                this.isStarted = false;
                this.players.red.resetScore();
                this.players.blue.resetScore();
                this.rounds = [];
                this.currentRoundIndex = -1;
            }

            hasWinner() {
                return this.players.red.totalScore >= this.winningScore ||
                       this.players.blue.totalScore >= this.winningScore;
            }
        }

        class UIState {
            constructor() {
                this.lowScoreZoneThresholdPx = 10;
                this.autoEndDelayMs = 1500;
                this.autoEndDelayOuterMs = 3000;
                this.draggedPokId = null;
                this.autoEndTimeout = null;
                this.domElements = {
                    startSelector: null,
                    nextPlayer: null,
                    tableContainer: null,
                    mainRedTotal: null,
                    mainBlueTotal: null,
                    redRound: null,
                    blueRound: null,
                    redPoks: null,
                    bluePoks: null,
                    roundModal: null,
                    modalWinner: null,
                    modalRoundScores: null,
                    modalTotalScores: null
                };
                this.pokElements = new Map();
            }

            initDOMCache() {
                const dom = this.domElements;
                dom.startSelector = document.getElementById('startSelector');
                dom.nextPlayer = document.getElementById('nextPlayer');
                dom.tableContainer = document.getElementById('tableContainer');
                dom.mainRedTotal = document.getElementById('mainRedTotal');
                dom.mainBlueTotal = document.getElementById('mainBlueTotal');
                dom.redRound = document.getElementById('redRound');
                dom.blueRound = document.getElementById('blueRound');
                dom.redPoks = document.getElementById('redPoks');
                dom.bluePoks = document.getElementById('bluePoks');
                dom.roundModal = document.getElementById('roundModal');
                dom.modalWinner = document.getElementById('modalWinner');
                dom.modalRoundScores = document.getElementById('modalRoundScores');
                dom.modalTotalScores = document.getElementById('modalTotalScores');
            }

            clearAutoEndTimer() {
                if (this.autoEndTimeout) {
                    clearTimeout(this.autoEndTimeout);
                    this.autoEndTimeout = null;
                }
            }

            setAutoEndTimer(delay, callback) {
                this.clearAutoEndTimer();
                this.autoEndTimeout = setTimeout(callback, delay);
            }

            clearPokElements() {
                this.pokElements.clear();
            }

            getPokElement(pokId) {
                return this.pokElements.get(pokId);
            }

            setPokElement(pokId, element) {
                this.pokElements.set(pokId, element);
            }

            deletePokElement(pokId) {
                this.pokElements.delete(pokId);
            }
        }

        // ============================================
        // Event Processor & Orchestrator
        // ============================================

        class EventProcessor {
            constructor(game, eventLog, stateMachine, services) {
                this.game = game;
                this.eventLog = eventLog;
                this.stateMachine = stateMachine;
                this.services = services;
            }

            process(event) {
                this.eventLog.record(event);

                const result = this.applyEvent(event);
                if (!result.success) {
                    console.warn(`Event ${event.type} failed:`, result.reason);
                    return result;
                }

                return result;
            }

            applyEvent(event) {
                switch(event.type) {
                    case EVENT_TYPES.GAME_STARTED:
                        return this.handleGameStarted(event);
                    case EVENT_TYPES.POK_PLACED:
                        return this.handlePokPlaced(event);
                    case EVENT_TYPES.POK_MOVED:
                        return this.handlePokMoved(event);
                    case EVENT_TYPES.POK_REMOVED:
                        return this.handlePokRemoved(event);
                    case EVENT_TYPES.PLAYER_SWITCHED:
                        return this.handlePlayerSwitched(event);
                    case EVENT_TYPES.ROUND_ENDED:
                        return this.handleRoundEnded(event);
                    case EVENT_TYPES.ROUND_STARTED:
                        return this.handleRoundStarted(event);
                    case EVENT_TYPES.GAME_RESET:
                        return this.handleGameReset(event);
                    default:
                        return { success: true };
                }
            }

            handleGameStarted(event) {
                this.stateMachine.transition('GAME_STARTED');
                this.stateMachine.transition('PLAYER_TURN');
                return { success: true };
            }

            handlePokPlaced(event) {
                const round = this.game.getCurrentRound();
                if (round.isRoundComplete()) {
                    this.stateMachine.transition('ROUND_COMPLETE');
                } else {
                    this.stateMachine.transition('POK_PLACED');
                }
                return { success: true };
            }

            handlePokMoved(event) {
                return { success: true };
            }

            handlePokRemoved(event) {
                return { success: true };
            }

            handlePlayerSwitched(event) {
                if (this.stateMachine.getState() !== 'ROUND_COMPLETE') {
                    this.stateMachine.transition('PLAYER_TURN');
                }
                return { success: true };
            }

            handleRoundEnded(event) {
                this.stateMachine.transition('ROUND_ENDED');
                if (event.data.gameComplete) {
                    this.stateMachine.transition('GAME_COMPLETE');
                }
                return { success: true };
            }

            handleRoundStarted(event) {
                this.stateMachine.transition('PLAYER_TURN');
                return { success: true };
            }

            handleGameReset(event) {
                this.stateMachine.transition('GAME_NOT_STARTED');
                return { success: true };
            }
        }

        class GameOrchestrator {
            constructor() {
                this.game = new Game();
                this.eventLog = new EventLog();
                this.stateMachine = new GameStateMachine();

                this.services = {
                    rules: new RulesEngine(),
                    scoring: new ScoringService(),
                    pok: new PokService(),
                    ui: new UIService()
                };

                this.eventProcessor = new EventProcessor(
                    this.game,
                    this.eventLog,
                    this.stateMachine,
                    this.services
                );

                this.uiState = new UIState();
            }

            init() {
                this.services.ui.init();
                this.uiState.initDOMCache();
            }

            startGame(startingPlayerId) {
                this.game.startNewGame(startingPlayerId);

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.GAME_STARTED, {
                    startingPlayer: startingPlayerId
                }));

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.ROUND_STARTED, {
                    roundNumber: 0,
                    startingPlayer: startingPlayerId
                }));

                this.services.ui.hideStartSelector();
                this.services.ui.updateCurrentPlayer(this.game.getCurrentRound());
            }

            placePok(zone, clickPosition) {
                const round = this.game.getCurrentRound();
                if (!round) return;

                if (!this.services.rules.canPlacePok(round, round.currentPlayerId)) {
                    return;
                }

                const rect = zone.getBoundingClientRect();
                const position = {
                    x: clickPosition.clientX - rect.left,
                    y: clickPosition.clientY - rect.top
                };

                const scoreResult = this.services.scoring.calculateZoneScore(zone, position, rect);
                const zoneId = zone.dataset.zone || zone.id;

                const pok = this.services.pok.createPok(
                    round.currentPlayerId,
                    scoreResult.points,
                    position,
                    zoneId,
                    scoreResult.isHigh
                );

                round.addPok(pok);

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.POK_PLACED, {
                    pokId: pok.id,
                    playerId: pok.playerId,
                    zoneId: pok.zoneId,
                    position: position,
                    points: pok.points,
                    isHighScore: pok.isHighScore,
                    roundNumber: round.roundNumber,
                    redPoksRemaining: round.redPoksRemaining,
                    bluePoksRemaining: round.bluePoksRemaining
                }));

                const pokElement = this.services.pok.createPokElement(pok);
                this.services.pok.attachPokToZone(pokElement, zone);
                this.services.pok.setPokElement(pok.id, pokElement);
                this.setupPokHandlers(pokElement, pok.id);

                this.services.ui.updateScores(this.game);

                if (round.isRoundComplete()) {
                    this.uiState.setAutoEndTimer(this.uiState.autoEndDelayMs, () => this.endRound());
                    return;
                }

                this.switchPlayer();
            }

            switchPlayer() {
                const round = this.game.getCurrentRound();
                if (!round) return;

                const previousPlayer = round.currentPlayerId;
                const nextPlayer = this.services.rules.getNextPlayer(round);
                round.currentPlayerId = nextPlayer;

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.PLAYER_SWITCHED, {
                    from: previousPlayer,
                    to: nextPlayer,
                    roundNumber: round.roundNumber,
                    redScore: round.scores.red,
                    blueScore: round.scores.blue
                }));

                this.services.ui.updateCurrentPlayer(round);
            }

            removePok(pokId) {
                this.uiState.clearAutoEndTimer();

                const round = this.game.getCurrentRound();
                if (!round) return;

                const pok = round.removePok(pokId);
                if (!pok) return;

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.POK_REMOVED, {
                    pokId: pok.id,
                    playerId: pok.playerId,
                    zoneId: pok.zoneId,
                    points: pok.points,
                    roundNumber: round.roundNumber
                }));

                this.services.pok.removePokElement(pokId);

                if (round.redPoksRemaining > 0 || round.bluePoksRemaining > 0) {
                    round.currentPlayerId = pok.playerId;
                    this.services.ui.updateCurrentPlayer(round);
                }
                this.services.ui.updateScores(this.game);
            }

            endRound() {
                const round = this.game.getCurrentRound();
                if (!round) return;

                if (!round.isRoundComplete()) {
                    if (!confirm('Not all poks have been placed. Continue anyway?')) {
                        return;
                    }
                }

                round.isComplete = true;

                const result = this.services.rules.calculateRoundWinner(round);
                let roundWinner = result.winner;
                const difference = result.pointsEarned;

                let winnerText = '';
                let bgClass = '';

                if (result.winner === PLAYER_ID.RED) {
                    this.game.players.red.addScore(difference);
                    winnerText = 'Red Wins!';
                    bgClass = 'red-bg';
                } else if (result.winner === PLAYER_ID.BLUE) {
                    this.game.players.blue.addScore(difference);
                    winnerText = 'Blue Wins!';
                    bgClass = 'blue-bg';
                } else {
                    winnerText = 'Round Tied!';
                    bgClass = 'tie-bg';
                    roundWinner = round.startingPlayerId === PLAYER_ID.RED ? PLAYER_ID.BLUE : PLAYER_ID.RED;
                }

                this.services.ui.updateScores(this.game);

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.ROUND_ENDED, {
                    roundNumber: round.roundNumber,
                    redScore: round.scores.red,
                    blueScore: round.scores.blue,
                    winner: roundWinner,
                    pointsEarned: difference,
                    redTotalScore: this.game.players.red.totalScore,
                    blueTotalScore: this.game.players.blue.totalScore,
                    gameComplete: this.services.rules.shouldEndGame(this.game)
                }));

                if (this.services.rules.shouldEndGame(this.game)) {
                    if (this.game.players.red.totalScore >= this.game.winningScore) {
                        winnerText = 'Red Wins the Game!';
                    } else {
                        winnerText = 'Blue Wins the Game!';
                    }
                }

                this.services.ui.showRoundModal(
                    winnerText,
                    round.scores.red,
                    round.scores.blue,
                    this.game.players.red.totalScore,
                    this.game.players.blue.totalScore,
                    bgClass
                );

                round.currentPlayerId = roundWinner;
            }

            continueToNextRound() {
                this.services.ui.hideRoundModal();

                if (this.services.rules.shouldEndGame(this.game)) {
                    this.resetGame();
                    return;
                }

                this.startNewRound();
            }

            startNewRound() {
                this.uiState.clearAutoEndTimer();

                const prevRound = this.game.getCurrentRound();
                if (!prevRound) return;

                const nextStarter = this.services.rules.getRoundStarter(prevRound);

                this.services.pok.clearAllPokElements();

                this.game.startNewRound(nextStarter);

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.ROUND_STARTED, {
                    roundNumber: this.game.rounds.length - 1,
                    startingPlayer: nextStarter
                }));

                this.services.ui.updateScores(this.game);
                this.services.ui.updateCurrentPlayer(this.game.getCurrentRound());
            }

            resetGame() {
                this.uiState.clearAutoEndTimer();

                this.services.pok.reset();

                this.game.reset();

                this.eventProcessor.process(new GameEvent(EVENT_TYPES.GAME_RESET, {
                    totalEvents: this.eventLog.events.length
                }));

                this.eventLog.printSummary();

                this.services.ui.showStartSelector();
                document.body.classList.remove(PLAYER_CLASS[PLAYER_ID.RED], PLAYER_CLASS[PLAYER_ID.BLUE]);

                this.services.ui.updateScores(this.game);
            }

            setupPokHandlers(pokElement, pokId) {
                pokElement.onclick = (e) => {
                    e.stopPropagation();
                    const round = this.game.getCurrentRound();
                    if (round && pokId === round.lastPlacedPokId) {
                        this.removePok(pokId);
                    }
                };

                this.makePokDraggable(pokElement, pokId);
            }

            makePokDraggable(pokElement, pokId) {
                pokElement.draggable = true;

                pokElement.addEventListener('dragstart', (e) => {
                    this.uiState.draggedPokId = pokId;
                    pokElement.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                pokElement.addEventListener('dragend', (e) => {
                    pokElement.classList.remove('dragging');
                    this.uiState.draggedPokId = null;
                });
            }
        }

        // ============================================
        // Global State
        // ============================================

        let orchestrator = new GameOrchestrator();

        // ============================================
        // Initialization
        // ============================================

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => orchestrator.init());
        } else {
            orchestrator.init();
        }

        // ============================================
        // Global Functions (HTML Event Handlers)
        // ============================================

        function startGame(startingPlayerId) {
            orchestrator.startGame(startingPlayerId);
        }

        function placePok(zone, event) {
            orchestrator.placePok(zone, event);
        }

        function placePokOuter(event) {
            const round = orchestrator.game.getCurrentRound();
            if (!round) return;

            if (!orchestrator.services.rules.canPlacePok(round, round.currentPlayerId)) {
                return;
            }

            const rect = orchestrator.services.ui.domElements.tableContainer.getBoundingClientRect();
            const position = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };

            const pok = orchestrator.services.pok.createPok(
                round.currentPlayerId,
                0,
                position,
                null,
                true
            );

            round.addPok(pok);

            orchestrator.eventProcessor.process(new GameEvent(EVENT_TYPES.POK_PLACED, {
                pokId: pok.id,
                playerId: pok.playerId,
                zoneId: 'outer',
                position: position,
                points: 0,
                isHighScore: true,
                roundNumber: round.roundNumber,
                redPoksRemaining: round.redPoksRemaining,
                bluePoksRemaining: round.bluePoksRemaining
            }));

            const pokElement = orchestrator.services.pok.createPokElement(pok);
            pokElement.style.position = 'absolute';
            orchestrator.services.ui.domElements.tableContainer.appendChild(pokElement);
            orchestrator.services.pok.setPokElement(pok.id, pokElement);
            orchestrator.setupPokHandlers(pokElement, pok.id);

            orchestrator.services.ui.updateScores(orchestrator.game);

            if (round.isRoundComplete()) {
                orchestrator.uiState.setAutoEndTimer(orchestrator.uiState.autoEndDelayOuterMs, () => orchestrator.endRound());
                return;
            }

            orchestrator.switchPlayer();
        }

        function handlePokDrop(event, targetZone, isOuterZone = false) {
            event.preventDefault();
            event.stopPropagation();

            if (!orchestrator.uiState.draggedPokId) return;

            const round = orchestrator.game.getCurrentRound();
            if (!round) return;

            const pok = round.getPokById(orchestrator.uiState.draggedPokId);
            const pokElement = orchestrator.services.pok.getPokElement(orchestrator.uiState.draggedPokId);
            if (!pok || !pokElement) return;

            orchestrator.uiState.clearAutoEndTimer();

            round.scores.addPoints(pok.playerId, -pok.points);

            let newPoints, newX, newY, newZoneId, newIsHigh;

            if (isOuterZone) {
                const rect = orchestrator.services.ui.domElements.tableContainer.getBoundingClientRect();
                newPoints = 0;
                newX = event.clientX - rect.left;
                newY = event.clientY - rect.top;
                newZoneId = null;
                newIsHigh = true;

                if (pokElement.parentElement !== orchestrator.services.ui.domElements.tableContainer) {
                    orchestrator.services.ui.domElements.tableContainer.appendChild(pokElement);
                    pokElement.style.position = 'absolute';
                }
            } else {
                const rect = targetZone.getBoundingClientRect();
                const position = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };

                const scoreResult = orchestrator.services.scoring.calculateZoneScore(targetZone, position, rect);
                newPoints = scoreResult.points;
                newIsHigh = scoreResult.isHigh;
                newX = position.x;
                newY = position.y;
                newZoneId = targetZone.dataset.zone || targetZone.id;

                if (pokElement.parentElement !== targetZone) {
                    targetZone.appendChild(pokElement);
                }
            }

            const oldPosition = { x: pok.position.x, y: pok.position.y };
            const oldPoints = pok.points;
            const oldZoneId = pok.zoneId;

            pok.updatePosition(newX, newY);
            pok.updateScore(newPoints, newIsHigh);
            pok.updateZone(newZoneId);

            orchestrator.eventProcessor.process(new GameEvent(EVENT_TYPES.POK_MOVED, {
                pokId: pok.id,
                playerId: pok.playerId,
                fromZone: oldZoneId,
                toZone: newZoneId,
                oldPosition: oldPosition,
                newPosition: { x: newX, y: newY },
                oldPoints: oldPoints,
                newPoints: newPoints,
                roundNumber: round.roundNumber
            }));

            pokElement.style.left = `${newX}px`;
            pokElement.style.top = `${newY}px`;
            pokElement.style.transform = 'translate(-50%, -50%)';
            pokElement.textContent = newPoints;

            if (newIsHigh) {
                pokElement.classList.remove('low-score');
            } else {
                pokElement.classList.add('low-score');
            }

            round.scores.addPoints(pok.playerId, newPoints);

            orchestrator.services.ui.updateScores(orchestrator.game);

            if (round.isRoundComplete()) {
                orchestrator.uiState.setAutoEndTimer(orchestrator.uiState.autoEndDelayMs, () => orchestrator.endRound());
            }
        }

        function continueToNextRound() {
            orchestrator.continueToNextRound();
        }

    </script>
</body>
</html>
